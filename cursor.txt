
struct tdb_cursor{
    tdb_item *items_buf;
    uint64_t num_items;
    uint64_t items_buf_size;
    uint64_t trail_id;

    const tdb *db;
    const tdb_options *opt;
    struct tdb_decode_state *decode_state;
}

keep decode_state opaque, so tdb_cursor_next() can be inlined safely
without hurting ABI compatibility.

struct tdb_event{
    uint64_t timestamp;
    const tdb_item *items;
    uin32_t num_items;
}

tdb_options opt;
tdb_cursor = tdb_cursor_new(db, opt)
void tdb_cursor_reset(cursor) // cursor can be reused over many trails
void tdb_cursor_free()
int tdb_get_trail(cursor, uint64_t trail_id);
inline int tdb_cursor_next(tdb_cursor *cursor, tdb_event *event);

cursor has a small buffer of uint64_t items, items_buf, whose length is a multiple
of num_fields. An inline function, tdb_cursor_next() iterates over
the buffer until it is exhausted, and then calls a function like tdb_decode_trail
to decode the next batch of events in the buffer.

tdb_cursor_next() populates tdb_event based on items_buf, which should be an
O(1) operation.

tdb_get_trail() should check cursor->trail_id and if it is different than the
requested trail_id, it calls tdb_cursor_reset(cursor). This makes code cleaner
and makes sure tdb_cursor_reset() is always called for a new trail.

int main(int argc, char **argv)
{
    int err;
    static uint8_t hexuuid[33];
    tdb_cursor *cursor;
    tdb_event event;
    tdb *db = tdb_init();
    uint64_t trail_id;

    if ((err = tdb_open(db, argv[1]))){
        printf("Opening TrailDB at %s failed: %s\n", argv[1], tdb_error(err));
        return 1;
    }

    if (!(cursor = tdb_cursor_new(db, NULL))){
        printf("Could not create a cursor\n");
        return 1;
    }

    for (trail_id = 0; trail_id < tdb_num_trails(db); trail_id++){
        tdb_get_trail(cursor, trail_id);
        tdb_uuid_hex(tdb_get_uuid(db, trail_id), hexuuid);
        while (tdb_cursor_next(cursor, &event)){
            printf("%s ", hexuuid);
            tdb_printf(&event);
            printf("\n");
        }
    }
    tdb_cursor_free(cursor);
    tdb_free(db);

    return 0;
}

check in tdb_get_trail() that db->is_closed is not true.

Let's provide a utility / debugging function
tdb_printf(const tdb_event *event) and tdb_fprint(FILE *out,
const tdb_event *event) (the latter can be used with membuffer)
